{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { ElementRef, PLATFORM_ID, Injectable, Inject, Directive, Input, NgModule } from '@angular/core';\nimport { isPlatformBrowser, DOCUMENT } from '@angular/common';\nimport { ReplaySubject, throwError } from 'rxjs';\n\n/** Default values for Component Input */\nconst DEFAULTS = {\n  target: null,\n  action: 'click',\n  duration: 650,\n  easing: 'easeInOutQuad',\n  offset: 0,\n  offsetMap: new Map()\n};\n/** Easing Colleciton */\nconst EASING = {\n  easeInQuad: time => {\n    return time * time;\n  },\n  easeOutQuad: time => {\n    return time * (2 - time);\n  },\n  easeInOutQuad: time => {\n    return time < 0.5 ? 2 * time * time : -1 + (4 - 2 * time) * time;\n  },\n  easeInCubic: time => {\n    return time * time * time;\n  },\n  easeOutCubic: time => {\n    return --time * time * time + 1;\n  },\n  easeInOutCubic: time => {\n    return time < 0.5 ? 4 * time * time * time : (time - 1) * (2 * time - 2) * (2 * time - 2) + 1;\n  },\n  easeInQuart: time => {\n    return time * time * time * time;\n  },\n  easeOutQuart: time => {\n    return 1 - --time * time * time * time;\n  },\n  easeInOutQuart: time => {\n    return time < 0.5 ? 8 * time * time * time * time : 1 - 8 * --time * time * time * time;\n  },\n  easeInQuint: time => {\n    return time * time * time * time * time;\n  },\n  easeOutQuint: time => {\n    return 1 + --time * time * time * time * time;\n  },\n  easeInOutQuint: time => {\n    return time < 0.5 ? 16 * time * time * time * time * time : 1 + 16 * --time * time * time * time * time;\n  },\n  easeOutElastic: time => {\n    return Math.pow(2, -10 * time) * Math.sin((time - 1 / 4) * (2 * Math.PI) / 1) + 1;\n  }\n};\n/**\n * Set of allowed events as triggers\n * for the Animation to start.\n */\nconst EVENTS = ['click', 'mouseenter', 'mouseover', 'mousedown', 'mouseup', 'dblclick', 'contextmenu', 'wheel', 'mouseleave', 'mouseout'];\n/**\n * Strip hash (#) from value.\n *\n * @param value \t\t\t\tThe given string value\n * @returns \t\t\t\t\tThe stripped string value\n */\nfunction stripHash(value) {\n  return value.substring(0, 1) === '#' ? value.substring(1) : value;\n}\n/**\n * Test if a given value is a string.\n *\n * @param value \t\t\t\t\tThe given value\n * @returns \t\t\t\t\t\tWhether the given value is a string\n */\nfunction isString(value) {\n  return typeof value === 'string' || value instanceof String;\n}\n/**\n * Test if a given Element is the Window.\n *\n * @param container \t\t\t\tThe given Element\n * @returns \t\t\t\t\t\tWhether the given Element is Window\n */\nfunction isWindow(container) {\n  return container === window;\n}\n/**\n * Test if a given value is of type ElementRef.\n *\n * @param value \t\t\t\t\tThe given value\n * @returns               Whether the given value is a number\n */\nfunction isElementRef(value) {\n  return value instanceof ElementRef;\n}\n/**\n * Whether or not the given value is a Native Element.\n *\n * @param value           The given value\n * @returns               Whether or not the value is a Native Element\n */\nfunction isNativeElement(value) {\n  return value instanceof HTMLElement;\n}\n/**\n * Test if a given value is type number.\n *\n * @param value \t\t\t\t\tThe given value\n * @returns \t\t\t\t\t\tWhether the given value is a number\n */\nfunction isNumber(value) {\n  return !isNaN(parseFloat(value)) && isFinite(value);\n}\n\n/** Scroll To Animation */\nclass ScrollToAnimation {\n  /**\n   * Class Constructor.\n   *\n   * @param container            The Container\n   * @param listenerTarget       The Element that listens for DOM Events\n   * @param isWindow             Whether or not the listener is the Window\n   * @param to                   Position to scroll to\n   * @param options              Additional options for scrolling\n   * @param isBrowser            Whether or not execution runs in the browser\n   *                              (as opposed to the server)\n   */\n  constructor(container, listenerTarget, isWindow, to, options, isBrowser) {\n    this.container = container;\n    this.listenerTarget = listenerTarget;\n    this.isWindow = isWindow;\n    this.to = to;\n    this.options = options;\n    this.isBrowser = isBrowser;\n    /** Recursively loop over the Scroll Animation */\n    this.loop = () => {\n      this.timeLapsed += this.tick;\n      this.percentage = this.timeLapsed / this.options.duration;\n      this.percentage = this.percentage > 1 ? 1 : this.percentage;\n      // Position Update\n      this.position = this.startPosition + (this.startPosition - this.to <= 0 ? 1 : -1) * this.distance * EASING[this.options.easing](this.percentage);\n      if (this.lastPosition !== null && this.position === this.lastPosition) {\n        this.stop();\n      } else {\n        this.source$.next(this.position);\n        this.isWindow ? this.listenerTarget.scrollTo(0, Math.floor(this.position)) : this.container.scrollTop = Math.floor(this.position);\n        this.lastPosition = this.position;\n      }\n    };\n    this.tick = 16;\n    this.interval = null;\n    this.lastPosition = null;\n    this.timeLapsed = 0;\n    this.windowScrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;\n    if (!this.container) {\n      this.startPosition = this.windowScrollTop;\n    } else {\n      this.startPosition = this.isWindow ? this.windowScrollTop : this.container.scrollTop;\n    }\n    // Correction for Starting Position of nested HTML Elements\n    if (this.container && !this.isWindow) {\n      this.to = this.to - this.container.getBoundingClientRect().top + this.startPosition;\n    }\n    // Set Distance\n    const directionalDistance = this.startPosition - this.to;\n    this.distance = this.container ? Math.abs(this.startPosition - this.to) : this.to;\n    this.mappedOffset = this.options.offset;\n    // Set offset from Offset Map\n    if (this.isBrowser) {\n      this.options.offsetMap.forEach((value, key) => this.mappedOffset = window.innerWidth > key ? value : this.mappedOffset);\n    }\n    this.distance += this.mappedOffset * (directionalDistance <= 0 ? 1 : -1);\n    this.source$ = new ReplaySubject();\n  }\n  /**\n   * Start the new Scroll Animation.\n   *\n   * @returns         Observable containing a number\n   */\n  start() {\n    clearInterval(this.interval);\n    this.interval = setInterval(this.loop, this.tick);\n    return this.source$.asObservable();\n  }\n  /**\n   * Stop the current Scroll Animation Loop.\n   *\n   * @param force          Force to stop the Animation Loop\n   * @returns               Void\n   */\n  stop() {\n    clearInterval(this.interval);\n    this.interval = null;\n    this.source$.complete();\n  }\n}\n\n/**\n * The Scroll To Service handles starting, interrupting\n * and ending the actual Scroll Animation. It provides\n * some utilities to find the proper HTML Element on a\n * given page to setup Event Listeners and calculate\n * distances for the Animation.\n */\nlet ScrollToService = /*#__PURE__*/(() => {\n  class ScrollToService {\n    /**\n     * Construct and setup required paratemeters.\n     *\n     * @param document         A Reference to the Document\n     * @param platformId       Angular Platform ID\n     */\n    constructor(document, platformId) {\n      this.document = document;\n      this.platformId = platformId;\n      this.interruptiveEvents = ['mousewheel', 'DOMMouseScroll', 'touchstart'];\n    }\n    /**\n     * Target an Element to scroll to. Notice that the `TimeOut` decorator\n     * ensures the executing to take place in the next Angular lifecycle.\n     * This allows for scrolling to elements that are e.g. initially hidden\n     * by means of `*ngIf`, but ought to be scrolled to eventually.\n     *\n     * @todo type 'any' in Observable should become custom type like 'ScrollToEvent' (base class), see issue comment:\n     *  - https://github.com/nicky-lenaers/ngx-scroll-to/issues/10#issuecomment-317198481\n     *\n     * @param options         Configuration Object\n     * @returns               Observable\n     */\n    scrollTo(options) {\n      if (!isPlatformBrowser(this.platformId)) {\n        return new ReplaySubject().asObservable();\n      }\n      return this.start(options);\n    }\n    /**\n     * Start a new Animation.\n     *\n     * @todo Emit proper events from subscription\n     *\n     * @param options         Configuration Object\n     * @returns               Observable\n     */\n    start(options) {\n      // Merge config with default values\n      const mergedConfigOptions = {\n        ...DEFAULTS,\n        ...options\n      };\n      if (this.animation) {\n        this.animation.stop();\n      }\n      const targetNode = this.getNode(mergedConfigOptions.target);\n      if (mergedConfigOptions.target && !targetNode) {\n        return throwError(() => new Error('Unable to find Target Element'));\n      }\n      const container = this.getContainer(mergedConfigOptions, targetNode);\n      if (mergedConfigOptions.container && !container) {\n        return throwError(() => new Error('Unable to find Container Element'));\n      }\n      const listenerTarget = this.getListenerTarget(container) || window;\n      let to = container ? container.getBoundingClientRect().top : 0;\n      if (targetNode) {\n        to = isWindow(listenerTarget) ? window.scrollY + targetNode.getBoundingClientRect().top : targetNode.getBoundingClientRect().top;\n      }\n      // Create Animation\n      this.animation = new ScrollToAnimation(container, listenerTarget, isWindow(listenerTarget), to, mergedConfigOptions, isPlatformBrowser(this.platformId));\n      const onInterrupt = () => this.animation.stop();\n      this.addInterruptiveEventListeners(listenerTarget, onInterrupt);\n      // Start Animation\n      const animation$ = this.animation.start();\n      this.subscribeToAnimation(animation$, listenerTarget, onInterrupt);\n      return animation$;\n    }\n    /**\n     * Subscribe to the events emitted from the Scrolling\n     * Animation. Events might be used for e.g. unsubscribing\n     * once finished.\n     *\n     * @param animation$              The Animation Observable\n     * @param listenerTarget          The Listener Target for events\n     * @param onInterrupt             The handler for Interruptive Events\n     * @returns                       Void\n     */\n    subscribeToAnimation(animation$, listenerTarget, onInterrupt) {\n      const subscription = animation$.subscribe({\n        complete: () => {\n          this.removeInterruptiveEventListeners(this.interruptiveEvents, listenerTarget, onInterrupt);\n          subscription.unsubscribe();\n        }\n      });\n    }\n    /**\n     * Get the container HTML Element in which\n     * the scrolling should happen.\n     *\n     * @param options         The Merged Configuration Object\n     * @param targetNode    the targeted HTMLElement\n     */\n    getContainer(options, targetNode) {\n      let container = null;\n      if (options.container) {\n        container = this.getNode(options.container, true);\n      } else if (targetNode) {\n        container = this.getFirstScrollableParent(targetNode);\n      }\n      return container;\n    }\n    /**\n     * Add listeners for the Animation Interruptive Events\n     * to the Listener Target.\n     *\n     * @param events            List of events to listen to\n     * @param listenerTarget    Target to attach the listener on\n     * @param handler           Handler for when the listener fires\n     * @returns                 Void\n     */\n    addInterruptiveEventListeners(listenerTarget, handler) {\n      if (!listenerTarget) {\n        listenerTarget = window;\n      }\n      this.interruptiveEvents.forEach(event => listenerTarget.addEventListener(event, handler, this.supportPassive() ? {\n        passive: true\n      } : false));\n    }\n    /**\n     * Feature-detect support for passive event listeners.\n     *\n     * @returns       Whether or not passive event listeners are supported\n     */\n    supportPassive() {\n      let supportsPassive = false;\n      try {\n        const opts = Object.defineProperty({}, 'passive', {\n          get: () => {\n            supportsPassive = true;\n          }\n        });\n        window.addEventListener('testPassive', null, opts);\n        window.removeEventListener('testPassive', null, opts);\n      } catch (e) {}\n      return supportsPassive;\n    }\n    /**\n     * Remove listeners for the Animation Interrupt Event from\n     * the Listener Target. Specifying the correct handler prevents\n     * memory leaks and makes the allocated memory available for\n     * Garbage Collection.\n     *\n     * @param events            List of Interruptive Events to remove\n     * @param listenerTarget    Target to attach the listener on\n     * @param handler           Handler for when the listener fires\n     * @returns                 Void\n     */\n    removeInterruptiveEventListeners(events, listenerTarget, handler) {\n      if (!listenerTarget) {\n        listenerTarget = window;\n      }\n      events.forEach(event => listenerTarget.removeEventListener(event, handler));\n    }\n    /**\n     * Find the first scrollable parent Node of a given\n     * Element. The DOM Tree gets searched upwards\n     * to find this first scrollable parent. Parents might\n     * be ignored by CSS styles applied to the HTML Element.\n     *\n     * @param nativeElement     The Element to search the DOM Tree upwards from\n     * @returns                 The first scrollable parent HTML Element\n     */\n    getFirstScrollableParent(nativeElement) {\n      let style = window.getComputedStyle(nativeElement);\n      const overflowRegex = /(auto|scroll|overlay)/;\n      if (style.position === 'fixed') {\n        return null;\n      }\n      let parent = nativeElement;\n      while (parent.parentElement) {\n        parent = parent.parentElement;\n        style = window.getComputedStyle(parent);\n        if (style.position === 'absolute' || style.overflow === 'hidden' || style.overflowY === 'hidden') {\n          continue;\n        }\n        if (overflowRegex.test(style.overflow + style.overflowY) || parent.tagName === 'BODY') {\n          return parent;\n        }\n      }\n      return null;\n    }\n    /**\n     * Get the Target Node to scroll to.\n     *\n     * @param id              The given ID of the node, either a string or\n     *                        an element reference\n     * @param allowBodyTag    Indicate whether or not the Document Body is\n     *                        considered a valid Target Node\n     * @returns               The Target Node to scroll to\n     */\n    getNode(id, allowBodyTag = false) {\n      let targetNode;\n      if (isString(id)) {\n        if (allowBodyTag && (id === 'body' || id === 'BODY')) {\n          targetNode = this.document.body;\n        } else {\n          targetNode = this.document.getElementById(stripHash(id));\n        }\n      } else if (isNumber(id)) {\n        targetNode = this.document.getElementById(String(id));\n      } else if (isElementRef(id)) {\n        targetNode = id.nativeElement;\n      } else if (isNativeElement(id)) {\n        targetNode = id;\n      }\n      return targetNode;\n    }\n    /**\n     * Retrieve the Listener target. This Listener Target is used\n     * to attach Event Listeners on. In case of the target being\n     * the Document Body, we need the actual `window` to listen\n     * for events.\n     *\n     * @param container           The HTML Container element\n     * @returns                   The Listener Target to attach events on\n     */\n    getListenerTarget(container) {\n      if (!container) {\n        return null;\n      }\n      return this.isDocumentBody(container) ? window : container;\n    }\n    /**\n     * Test if a given HTML Element is the Document Body.\n     *\n     * @param element             The given HTML Element\n     * @returns                   Whether or not the Element is the\n     *                            Document Body Element\n     */\n    isDocumentBody(element) {\n      return element.tagName.toUpperCase() === 'BODY';\n    }\n  }\n  ScrollToService.ɵfac = function ScrollToService_Factory(t) {\n    return new (t || ScrollToService)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(PLATFORM_ID));\n  };\n  ScrollToService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ScrollToService,\n    factory: ScrollToService.ɵfac\n  });\n  return ScrollToService;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ScrollToDirective = /*#__PURE__*/(() => {\n  class ScrollToDirective {\n    constructor(elementRef, scrollToService, renderer2) {\n      this.elementRef = elementRef;\n      this.scrollToService = scrollToService;\n      this.renderer2 = renderer2;\n      this.ngxScrollTo = DEFAULTS.target;\n      this.ngxScrollToEvent = DEFAULTS.action;\n      this.ngxScrollToDuration = DEFAULTS.duration;\n      this.ngxScrollToEasing = DEFAULTS.easing;\n      this.ngxScrollToOffset = DEFAULTS.offset;\n      this.ngxScrollToOffsetMap = DEFAULTS.offsetMap;\n    }\n    /**\n     * Angular Lifecycle Hook - After View Init\n     *\n     * @todo Implement Subscription for Events\n     *\n     * @returns void\n     */\n    ngAfterViewInit() {\n      // Test Event Support\n      if (EVENTS.indexOf(this.ngxScrollToEvent) === -1) {\n        throw new Error(`Unsupported Event '${this.ngxScrollToEvent}'`);\n      }\n      // Listen for the trigger...\n      this.renderer2.listen(this.elementRef.nativeElement, this.ngxScrollToEvent, event => {\n        this.options = {\n          target: this.ngxScrollTo,\n          duration: this.ngxScrollToDuration,\n          easing: this.ngxScrollToEasing,\n          offset: this.ngxScrollToOffset,\n          offsetMap: this.ngxScrollToOffsetMap\n        };\n        this.scrollToService.scrollTo(this.options);\n      });\n    }\n  }\n  ScrollToDirective.ɵfac = function ScrollToDirective_Factory(t) {\n    return new (t || ScrollToDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(ScrollToService), i0.ɵɵdirectiveInject(i0.Renderer2));\n  };\n  ScrollToDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ScrollToDirective,\n    selectors: [[\"\", \"ngxScrollTo\", \"\"]],\n    inputs: {\n      ngxScrollTo: \"ngxScrollTo\",\n      ngxScrollToEvent: \"ngxScrollToEvent\",\n      ngxScrollToDuration: \"ngxScrollToDuration\",\n      ngxScrollToEasing: \"ngxScrollToEasing\",\n      ngxScrollToOffset: \"ngxScrollToOffset\",\n      ngxScrollToOffsetMap: \"ngxScrollToOffsetMap\"\n    }\n  });\n  return ScrollToDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/** Scroll To Module */\nlet ScrollToModule = /*#__PURE__*/(() => {\n  class ScrollToModule {\n    /**\n     * Guaranteed singletons for provided Services across App.\n     *\n     * @return          An Angular Module with Providers\n     */\n    static forRoot() {\n      return {\n        ngModule: ScrollToModule,\n        providers: [ScrollToService]\n      };\n    }\n  }\n  ScrollToModule.ɵfac = function ScrollToModule_Factory(t) {\n    return new (t || ScrollToModule)();\n  };\n  ScrollToModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ScrollToModule\n  });\n  ScrollToModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return ScrollToModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/*\n * Public API Surface of ngx-scroll-to\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ScrollToDirective, ScrollToModule, ScrollToService };\n//# sourceMappingURL=nicky-lenaers-ngx-scroll-to.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}